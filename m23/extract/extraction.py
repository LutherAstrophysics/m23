import sys

if "../../" not in sys.path:
    sys.path.insert(0, "../../")

import numpy as np
from astropy.io.fits import getdata as getfitsdata
from functools import cache
import math

# m23 imports
from m23.trans import createFitFileWithSameHeader
from m23.matrix import blockRegions
from m23.file import getLinesWithNumbersFromFile

# There are three methods of photometry
# 1. Aperture photometry: This is the method we use
# for the old camera, we create radii of 3, 4, 5 pixels around a star,
# and calculate its flux value
# 2. Profile photometry: TODO: This method was deemed
# inappropriate since the old images did not have
# as many pixels, but the new one have a lot more,
# so this is a method we want to try
# 3. Annular photometry

# radius the raidus used for finding star center,
# not the raidus of extraction


def newStarCenters(imageData, oldStarCenters, radius=5):
    def centerFinder(position):
        x, y = position

        colWghtSum = 0
        rowWghtSum = 0
        WghtSum = 0
        for col in range(-5, 6):
            for row in range(-5, 6):
                if math.ceil(math.sqrt((col ** 2) + (row ** 2))) <= 5:
                    WghtSum += imageData[round(y) + row][round(x) + col]
                    colWghtSum += imageData[round(y) + row][round(x) + col] * (x + col)
                    rowWghtSum += imageData[round(y) + row][round(x) + col] * (y + row)

        if WghtSum > 0:
            xWght = colWghtSum / WghtSum
            yWght = rowWghtSum / WghtSum
        else:
            xWght = x
            yWght = y

        return yWght, xWght

    return [centerFinder(position) for position in oldStarCenters]


def extractStars(imageData, referenceLogFileName, saveAs, imageName=None, radiusOfExtraction=5):
    starsPositionsInRefFile = starsPositionsInLogFile(referenceLogFileName)
    starsCentersInNewImage = newStarCenters(imageData, starsPositionsInRefFile)
    # ???
    regionSize = 64
    pixelsPerStar = np.count_nonzero(circleMatrix(radiusOfExtraction))

    ###
    # return
    # an array of arrays of 64x64 matrices
    @cache
    def backgroundRegion():
        row, col = imageData.shape
        # block in third row first column can be accessed by [2, 0]
        return blockRegions(imageData, (regionSize, regionSize)).reshape(
            row // regionSize, col // regionSize, regionSize, regionSize
        )

    ###
    # backgroundRegionTuple is (2, 0) if referring to region in
    # third row, first column
    @cache
    def backgroundAverage(backgroundRegionTuple):
        row, column = backgroundRegionTuple
        region = backgroundRegion()[row][column]
        # throw out the background of zeroes, since
        # they might be at the edge
        sortedData = np.sort(region, axis=None)
        nonZeroIndices = np.nonzero(sortedData)
        # ignore the zeros
        sortedData = sortedData[nonZeroIndices]

        centeredArray = sortedData[
            int(len(sortedData) // 2 - 0.05 * len(sortedData)): int(
                len(sortedData) // 2 + 0.05 * len(sortedData)
            )
        ]
        return np.mean(centeredArray)

    # ### starFlux
    # ###
    # ### return a threetuple
    # ### Total star flux + star pixels
    # ###   average background value for the star region
    # ###   star flux value after background subtraction
    def fluxSumForStar(position, radius):
        x, y = position
        starBox = imageData[x - radius: x +
                            radius + 1, y - radius: y + radius + 1]
        starBox = np.multiply(starBox, circleMatrix(radius))
        backgroundAverageInStarRegion = backgroundAverage(
            (x // regionSize, y // regionSize)
        )
        subtractedStarFlux = (
            np.sum(starBox) - backgroundAverageInStarRegion * pixelsPerStar
        )
        ### Convert to zero, in case there's any nan... this ensures that
        ### two log files correspond to same star number as they are
        ### or after reading with something like getLinesWithNumbersFromFile 
        ###  
        ### This step makes our normalization code fast!
        return np.nan_to_num(np.sum(starBox)), np.nan_to_num(backgroundAverageInStarRegion), np.nan_to_num(subtractedStarFlux)

    starsFluxes = [
        fluxSumForStar(np.round(position).astype("int"), radiusOfExtraction)
        for position in starsCentersInNewImage
    ]

    # create file
    with open(saveAs, "w") as fd:
        ###
        ### These 9 lines are to make sure it's the same format
        ### as the old log files generated by IDL code
        fd.write('\n')
        fd.write(f"Star Data Extractor Tool: (Note: This program mocks format of AIP_4_WIN) \n")
        fd.write(f"\tTotal no of stars: {len(starsFluxes)}\n")
        fd.write(f"\tImage {imageName}:\n")
        fd.write(f"\tRadius of star diaphragm {radiusOfExtraction}:\n")
        fd.write(f"\tSky annulus inner radius: \n")
        fd.write(f"\tSky annulus outer radius: \n")
        fd.write(f"\tThreshold factor: \n")


        headers = ["X", "Y", "XFWHM", "YFWHM", "Avg FWHM", "Sky ADU", "Star ADU 5", "Star ADU 4", "Star ADU 3"]
        fd.write("\t\t".join(headers))
        fd.write("\n")
        for starIndex in range(len(starsFluxes)):
            # we wont ignore any stars in this step
            # we'll filter out the bad stars in the normalization step
            ###
            ###
            data = starsCentersInNewImage[starIndex][::-1] + (0, 0, 0) + starsFluxes[starIndex][1:] + (0, 0)
            fd.write("\t\t".join(f"{item:.2f}" for item in data))
            fd.write("\n")


@cache
def starsPositionsInLogFile(fileName):
    linesWithNumbers = getLinesWithNumbersFromFile(fileName)
    # Assumes X and Y are the first two columns for the file
    ### NP WARNING
    ### IF dtype='float16' is specified, a number like '745.54' becomes 745.5
    ### Which means it gets rounded down, which is a HUGE problem if you're trying
    ### to match the output to IDL code
    ### So, we're using dtype='float'!!! 
    return [np.array(line.split()[:2], dtype="float") for line in linesWithNumbers]


@cache
def circleMatrix(radius):
    lengthOfSquare = radius * 2 + 1
    myMatrix = np.zeros(lengthOfSquare * lengthOfSquare).reshape(
        lengthOfSquare, lengthOfSquare
    )
    for row in range(-radius, radius + 1):
        for col in range(-radius, radius + 1):
            if math.ceil(math.sqrt((row) ** 2 + (col) ** 2)) <= radius:
                myMatrix[row + radius][col + radius] = 1
    return myMatrix
